#+title: Desmistificando Macros
#+subtitle: Um caso de Uso Real (=clj-rq=)
#+author: Josué Teodoro
#+date: 15/10/2024

=;; Clojure Brasil=

* Quem sou eu?

*Josué Teodoro Moreira*

- Engenheiro de Produto @ [[https://moclojer.com][moclojer]]
- Bacharelando em Sistemas de Informação
- Técnico em Informática p/ Internet
- Entusiasta de FOSS e Paradigma Funcional
- Eterno aprendiz

[[https://j0suetm.com][https://j0suetm.com]] [[mailto:me@j0suetm.com][me@j0suetm.com]] =@j0suetm=

* C preprocessors

#+begin_src c
  #include <stdio.h>

  #define GREET(greeting, name) greeting##name

  int main(void*) {
    printf(GREET("Hello ", "clj br"));
    // => printf("Hello clj br");
  }
#+end_src

* Macros pra todo lado!!!

#+begin_src clojure :results pp
  (source when)
#+end_src

#+RESULTS:
: (defmacro when
:   "Evaluates test. If logical true, evaluates body in an implicit do."
:   {:added "1.0"}
:   [test & body]
:   (list 'if test (cons 'do body)))
: 
: 

#+begin_src clojure :results pp
  (macroexpand '(when (= 1 1) (prn "hello clj-br")))
#+end_src

#+RESULTS:
: (if (= 1 1) (do (prn "hello clj-br")))
: 

* Macros

Função que extende o compilador, transformando um ou mais forms em um form final. Esse form final é então evaluado em runtime.

#+begin_src clojure :results pp
  (defmacro my-eval
    "This is my beautiful macro. It does nothing."
    [form]
    form)

  (my-eval (+ 1 4))
  ;; => (+ 1 4) => 5
#+end_src

#+RESULTS:
  : 5
  : 

** Forms podem ser manipulados

#+begin_src clojure :results pp
  (defmacro sum->mult
    "Changes a sum form to a multiplication form"
    [form]
    (list '+ (nth form 1) (nth form 2)))

  (sum->mult (+ 4 3))
  ;; => (* 4 3) => 12
#+end_src

#+RESULTS:
: 7
: 
  
* Forms, Símbolos, Valores, etc

#+begin_src clojure
  5
  ;; => valor 5
  prn
  ;; => valor da função `clojure.core/prn`
  'prn
  ;; => símbolo prn
  (symbol "clojure.core" "prn")
  ;; => símbolo clojure.core/prn

  ;; todos são forms
#+end_src

** Símbolos e Valores nas Macros

#+begin_src clojure :results pp
  (defmacro prn-when
    [test value]
    (list when test
          (list prn value)))

  (prn-when (= 1 1) "hello clj-br")
  ;; => Exception
#+end_src

#+RESULTS:
: class clojure.lang.Compiler$CompilerException

#+begin_src clojure :results pp
  (defmacro prn-when
    [test value]
    (list 'when test
          (list 'prn value)))

  (clojure.pprint/pprint
   (macroexpand '(prn-when (= 1 1) "hello clj-br")))
  (prn-when (= 1 1) "hello clj-br")
#+end_src

#+RESULTS:
: (if (= 1 1) (do (prn "hello clj-br")))
: "hello clj-br"
: 
: 

** Vamos diminuir essas quotes

#+begin_src clojure :results pp
  (defmacro prn-when
    [test value]
    '(when test
       (prn value)))

  (clojure.pprint/pprint
   (macroexpand '(prn-when (= 1 1) "hello clj-br")))

  ;; tem algo de errado aqui!!
#+end_src

#+RESULTS:
: (if test (do (prn value)))
: 
: 

*** Os valores não são símbolos

#+begin_src clojure :results pp
  (defmacro prn-when
    [test value]
    `(when ~test
       (prn ~value)))

  (clojure.pprint/pprint
   (macroexpand '(prn-when (= 1 1) "hello clj-br")))
  (prn-when (= 1 1) "hello clj-br")
#+end_src

#+RESULTS:
: (if (= 1 1) (do (clojure.core/prn "hello clj-br")))
: "hello clj-br"
: 
: 

** Emendando símbolos

#+begin_src clojure :results pp
  (defmacro prn-when
    [test & values]
    `(when ~test
       (prn (str ~@values))))

  (clojure.pprint/pprint
   (macroexpand
    '(prn-when (= 1 1) "hello clj-br! "
               "Espero que estejam "
               (+ 1 1) "gostando!")))
  (prn-when (= 1 1)
    "hello clj-br! " "Espero que estejam "
    (+ 1 1) " gostando!")
#+end_src

#+RESULTS:
: (if
:  (= 1 1)
:  (do
:   (clojure.core/prn
:    (clojure.core/str
:     "hello clj-br! "
:     "Espero que estejam "
:     (+ 1 1)
:     "gostando!"))))
: "hello clj-br! Espero que estejam 2 gostando!"
:
:

* Clj-RQ

[[https://github.com/moclojer/clj-rq][github.com/moclojer/clj-rq]]

* That's all folks!

Obrigado pela sua atenção!!!
